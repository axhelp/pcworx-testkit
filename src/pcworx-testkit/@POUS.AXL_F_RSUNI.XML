<project xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.kw-software.com/xml/PLCopen/TC6_XML_V10_KW.xsd">
	<fileHeader companyName="Phoenix Contact" companyURL="https://www.phoenixcontact-software.com" productName="PC WORX" productVersion="6.30" productRelease="Build 665" creationDateTime="2020-11-11T14:22:49" contentDescription="###XMLINFO=2;1;"/>
	<contentHeader name="pcworx-testkit" version="1605267799" modificationDateTime="2020-11-13T14:43:19" connectionCheck="true">
		<coordinateInfo>
			<pageSize x="999" y="9999"/>
			<fbd>
				<scaling x="2" y="2"/>
			</fbd>
			<ld>
				<scaling x="2" y="2"/>
			</ld>
			<sfc>
				<scaling x="2" y="2"/>
			</sfc>
		</coordinateInfo>
	</contentHeader>
	<types>
		<dataTypes/>
		<pous>
			<pou name="AXL_F_RSUNI" pouType="functionBlock" pouGroup="Serial" lastChange="2020-11-13T14:43:19">
				<interface>
					<inputVars retain="false">
						<variable name="xConsoleLog" group="Inputs">
							<type>
								<BOOL/>
							</type>
						</variable>
						<variable name="strConsoleId" group="Inputs">
							<type>
								<string length="80"/>
							</type>
						</variable>
					</inputVars>
					<inOutVars retain="false">
						<variable name="udtRS485Line" group="Inouts">
							<type>
								<derived name="udtAXL_F_RS_UNI_Buffer"/>
							</type>
						</variable>
						<variable name="arrInputAddress" group="Inouts">
							<type>
								<derived name="MB2_AXL_RSUNI2_ARR_B_0_19"/>
							</type>
							<documentation>
								<html xmlns="http://www.w3.org/1999/xhtml">
									<p xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">Process Data Input</p>
								</html>
							</documentation>
						</variable>
						<variable name="arrOutputAddress" group="Inouts">
							<type>
								<derived name="MB2_AXL_RSUNI2_ARR_B_0_19"/>
							</type>
							<documentation>
								<html xmlns="http://www.w3.org/1999/xhtml">
									<p xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">Process Data Output</p>
								</html>
							</documentation>
						</variable>
					</inOutVars>
					<localVars retain="false">
						<variable name="R_TRIG_xSending" group="FB">
							<type>
								<derived name="R_TRIG"/>
							</type>
						</variable>
						<variable name="Console" group="FB">
							<type>
								<derived name="Console"/>
							</type>
						</variable>
						<variable name="udtBufferReceive" group="Internal">
							<type>
								<derived name="udtAXL_F_RS_UNI_Buffer"/>
							</type>
						</variable>
						<variable name="udtBufferSend" group="Internal">
							<type>
								<derived name="udtAXL_F_RS_UNI_Buffer"/>
							</type>
						</variable>
						<variable name="xSending" group="Internal">
							<type>
								<BOOL/>
							</type>
						</variable>
						<variable name="iByteNum" group="Internal">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="iBytesToCopy" group="Internal">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="bStatusBits" group="Internal">
							<type>
								<BYTE/>
							</type>
						</variable>
						<variable name="wNumberOfCharactersReceived" group="Internal">
							<type>
								<WORD/>
							</type>
						</variable>
						<variable name="iFirstAddressIndex" group="Internal">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="iLastAddressIndex" group="Internal">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="iAddressIndex" group="Internal">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="iFirstBufferIndex" group="Internal">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="iByteToCopy" group="Internal">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="iWordsToSend" group="Internal">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="arrInputAddressRememdered" group="Internal">
							<type>
								<derived name="MB2_AXL_RSUNI2_ARR_B_0_19"/>
							</type>
							<documentation>
								<html xmlns="http://www.w3.org/1999/xhtml">
									<p xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">Process Data Input</p>
								</html>
							</documentation>
						</variable>
						<variable name="udtRS485LineCopy" group="Internal">
							<type>
								<derived name="udtAXL_F_RS_UNI_Buffer"/>
							</type>
						</variable>
						<variable name="bFillLevel" group="Default">
							<type>
								<BYTE/>
							</type>
						</variable>
						<variable name="MAX_SEND_LENGTH" group="Default">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="BufferHandler" group="Default">
							<type>
								<derived name="Buffer"/>
							</type>
						</variable>
						<variable name="MAX_RCV_LENGTH" group="Default">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="xCommandChanged" group="Default">
							<type>
								<BOOL/>
							</type>
						</variable>
						<variable name="iIndex" group="Default">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="diCommandsCounter" group="Default">
							<type>
								<DINT/>
							</type>
						</variable>
						<variable name="iBytesReceived" group="Default">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="iBytesTransmitted" group="Default">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="wWordsReceived" group="Default">
							<type>
								<WORD/>
							</type>
						</variable>
						<variable name="wWordsTransmitted" group="Default">
							<type>
								<WORD/>
							</type>
						</variable>
						<variable name="iBufferReceiveLengthRemembered" group="Default">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="xBufferReceiveLengtChanged" group="Default">
							<type>
								<BOOL/>
							</type>
						</variable>
						<variable name="iBufferSendLengthRemembered" group="Default">
							<type>
								<INT/>
							</type>
						</variable>
						<variable name="xBufferSendeLengtChanged" group="Default">
							<type>
								<BOOL/>
							</type>
						</variable>
						<variable name="xBufferSendLengthChanged" group="Default">
							<type>
								<BOOL/>
							</type>
						</variable>
						<variable name="bPushByte" group="Default">
							<type>
								<BYTE/>
							</type>
						</variable>
						<variable name="bPulledByte" group="Default">
							<type>
								<BYTE/>
							</type>
						</variable>
						<variable name="wBytesReceived" group="Default">
							<type>
								<WORD/>
							</type>
						</variable>
						<variable name="wBytesTransmitted" group="Default">
							<type>
								<WORD/>
							</type>
						</variable>
						<variable name="udiRevRemembered" group="Default">
							<type>
								<UDINT/>
							</type>
						</variable>
					</localVars>
				</interface>
				<body>
					<ST>
						<worksheet name="AXL_F_RSUNI">
							<html xmlns="http://www.w3.org/1999/xhtml">
								<p xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">(* ========================================== Constants ========================================================= *)<br/>MAX_SEND_LENGTH := 17;<br/>MAX_RCV_LENGTH  := 17;<br/>(* ============================================================================================================== *)<br/>
									<br/>
									<br/>(* ========================================== Clearing data ===================================================== *)<br/>FOR iByteToCopy	:= 1 TO 14 DO<br/>
									<br/>	arrOutputAddress[iByteToCopy] := BYTE#16#00;<br/>
									<br/>END_FOR;<br/>(* ============================================================================================================== *)<br/>
									<br/>
									<br/>(* ============================================= Module status bits ============================================= *)<br/>bStatusBits.X0 := udtBufferReceive.iLength &gt; 0; 	(* Receive buffer not empty *)<br/>bStatusBits.X1 := FALSE; 							(* Receive error *)<br/>bStatusBits.X2 := FALSE; 							(* Transmit error *)<br/>bStatusBits.X3 := FALSE; 							(* DCD *)<br/>bStatusBits.X4 := FALSE; 							(* Receive buffer full *)<br/>bStatusBits.X5 := FALSE; 							(* Transmit buffer full*)<br/>bStatusBits.X6 := udtBufferSend.iLength &gt; 0; 		(* Transmit buffer not empty *)<br/>bStatusBits.X7 := FALSE;							(* DSR *)<br/>
									<br/>(* =============================================================================================================== *)<br/>
									<br/>(* Check if command changed *)<br/>xCommandChanged                 := FALSE;<br/>FOR iIndex := 0 TO 19 DO<br/>    xCommandChanged             := xCommandChanged OR (arrInputAddress[iIndex] &lt;&gt; arrInputAddressRememdered[iIndex]);<br/>END_FOR;<br/>
									<br/>IF xCommandChanged THEN<br/>    diCommandsCounter           := diCommandsCounter + DINT#1;<br/>END_IF;<br/>
									<br/>(* Remember command *)<br/>FOR iIndex := 0 TO 19 DO<br/>    arrInputAddressRememdered[iIndex] := arrInputAddress[iIndex];<br/>END_FOR;<br/>
									<br/>(* Check if Receive Buffer length changed*)<br/>xBufferReceiveLengtChanged      := FALSE;<br/>IF udtBufferReceive.iLength &lt;&gt; iBufferReceiveLengthRemembered THEN<br/>    xBufferReceiveLengtChanged  := TRUE;<br/>END_IF;<br/>iBufferReceiveLengthRemembered  := udtBufferReceive.iLength;<br/>
									<br/>(* Check if Send Buffer length changed*)<br/>xBufferSendLengthChanged         := FALSE;<br/>IF udtBufferSend.iLength &lt;&gt; iBufferSendLengthRemembered THEN<br/>    xBufferSendLengthChanged    := TRUE;<br/>END_IF;<br/>iBufferSendLengthRemembered     := udtBufferSend.iLength;<br/>(* ======================================== Execute commands ======================================================*)<br/>
									<br/>(* "Read number of characters received" command *)<br/>IF arrInputAddress[0] = BYTE#16#00 THEN<br/>
									<br/>	IF xConsoleLog AND xBufferReceiveLengtChanged THEN<br/>		Console.strSource				:= strConsoleId;<br/>		Console.strMessage				:= CONCAT('ReadNumberOfChar command, number ', INT_TO_STRING(udtBufferReceive.iLength, '%d'));<br/>		Console();<br/>	END_IF;<br/>
									<br/>	arrOutputAddress[0] 			:= arrInputAddress[0];						(* Command mirror *)<br/>	arrOutputAddress[1] 			:= bStatusBits;								(* Status bits *)<br/>
									<br/>	wNumberOfCharactersReceived 	:= INT_TO_WORD(udtBufferReceive.iLength);<br/>    IF udtBufferReceive.iLength &gt;= 3096 THEN<br/>        bFillLevel                  := BYTE#03;<br/>    ELSIF udtBufferReceive.iLength &gt;= 2096 THEN<br/>        bFillLevel                  := BYTE#02;<br/>    ELSIF udtBufferReceive.iLength &gt;= 1096 THEN<br/>        bFillLevel                  := BYTE#01;<br/>    ELSE<br/>        bFillLevel                  := BYTE#000;<br/>    END_IF;<br/>	arrOutputAddress[2] 			:= wNumberOfCharactersReceived.B0;<br/>	arrOutputAddress[3] 			:= wNumberOfCharactersReceived.B1;<br/>    arrOutputAddress[4]             := bFillLevel;<br/>
									<br/>(* “Transmit characters” command *)<br/>ELSIF (arrInputAddress[0] = BYTE#16#10 <br/>	OR arrInputAddress[0] = BYTE#16#50)<br/>	AND NOT xSending <br/>    AND xCommandChanged<br/>	THEN<br/>
									<br/>    iBytesToCopy				:= BYTE_TO_INT(arrInputAddress[2]);<br/>
									<br/>	IF xConsoleLog THEN<br/>		Console.strSource			:= strConsoleId;<br/>		Console.strMessage			:= CONCAT ('TransmitChar command length ', INT_TO_STRING(iBytesToCopy, '%d'));<br/>		Console();<br/>	END_IF;<br/>
									<br/>	arrOutputAddress[0] 		:= arrInputAddress[0];						(* Command mirror *)<br/>	arrOutputAddress[1] 		:= bStatusBits;								(* Status bits *)<br/>
									<br/>	iFirstAddressIndex			:= 3;<br/>	iLastAddressIndex			:= iFirstAddressIndex + MIN(iBytesToCopy - 1, MAX_SEND_LENGTH);<br/>	iFirstBufferIndex			:= 0;<br/>
									<br/>	FOR iAddressIndex := iFirstAddressIndex TO iLastAddressIndex DO<br/>        BufferHandler.xPull     := FALSE;<br/>        BufferHandler.xPush     := TRUE;<br/>        BufferHandler.bPushByte := arrInputAddress[iAddressIndex];<br/>        BufferHandler.udtBuffer := udtBufferSend;<br/>        BufferHandler();<br/>        udtBufferSend           := BufferHandler.udtBuffer;<br/>	END_FOR;<br/>
									<br/>	xSending					:= TRUE;<br/>
									<br/>(* Store characters” command *)<br/>ELSIF (arrInputAddress[0] = BYTE#16#20 <br/>	OR arrInputAddress[0] = BYTE#16#60) <br/>	AND NOT xSending <br/>    AND (xCommandChanged OR xBufferSendLengthChanged)<br/>	THEN<br/>
									<br/>    iBytesToCopy				:= BYTE_TO_INT(arrInputAddress[2]);<br/>
									<br/>	IF xConsoleLog THEN<br/>		Console.strSource			:= strConsoleId;<br/>		Console.strMessage			:= CONCAT ('StoreChar command length ', INT_TO_STRING(iBytesToCopy, '%d'));<br/>		Console();<br/>	END_IF;<br/>
									<br/>	arrOutputAddress[0] 		:= arrInputAddress[0];						(* Command mirror *)<br/>	arrOutputAddress[1] 		:= bStatusBits;								(* Status bits *)<br/>
									<br/>	iFirstAddressIndex			:= 3;<br/>	iLastAddressIndex			:= iFirstAddressIndex + MIN(iBytesToCopy - 1, MAX_SEND_LENGTH);<br/>	iFirstBufferIndex			:= 0;<br/>
									<br/>	FOR iAddressIndex := iFirstAddressIndex TO iLastAddressIndex DO<br/>        BufferHandler.xPull     := FALSE;<br/>        BufferHandler.xPush     := TRUE;<br/>        BufferHandler.bPushByte := arrInputAddress[iAddressIndex];<br/>        BufferHandler.udtBuffer := udtBufferSend;<br/>        BufferHandler();<br/>        udtBufferSend           := BufferHandler.udtBuffer;<br/>	END_FOR;<br/>
									<br/>(* "Read characters" command *)<br/>ELSIF arrInputAddress[0] = BYTE#16#30<br/>    AND xCommandChanged THEN<br/>
									<br/>	arrOutputAddress[0] 		:= arrInputAddress[0];						(* Command mirror *)<br/>	bStatusBits.X0 				:= FALSE;<br/>	arrOutputAddress[1] 		:= bStatusBits;								(* Status bits *)<br/>
									<br/>	arrOutputAddress[2] 		:= INT_TO_BYTE(udtBufferReceive.iLength);	(* Number of valid characters available in the input data *)<br/>
									<br/>	iBytesToCopy 				:= MIN(udtBufferReceive.iLength, MAX_RCV_LENGTH);<br/>    arrOutputAddress[2]         := INT_TO_BYTE(iBytesToCopy);<br/>
									<br/>    IF xConsoleLog THEN<br/>		Console.strSource			:= strConsoleId;<br/>		Console.strMessage			:= CONCAT('ReadChar command, length ', INT_TO_STRING(iBytesToCopy, '%d'));<br/>		Console();<br/>	END_IF;<br/>
									<br/>	iFirstAddressIndex			:= 3;<br/>	iLastAddressIndex			:= iFirstAddressIndex + iBytesToCopy - 1;<br/>	iFirstBufferIndex			:= 0;<br/>	FOR iAddressIndex := iFirstAddressIndex TO iLastAddressIndex DO<br/>        BufferHandler.xPull             := TRUE;<br/>        BufferHandler.xPush             := FALSE;<br/>        BufferHandler.udtBuffer         := udtBufferReceive;<br/>        BufferHandler();<br/>        udtBufferReceive                := BufferHandler.udtBuffer;<br/>		arrOutputAddress[iAddressIndex] := BufferHandler.bPulledByte;<br/>	END_FOR;<br/>
									<br/>	(*udtBufferReceive.iWordsNo	:= 0;*)<br/>
									<br/>
									<br/>(* "Read counters" command *)<br/>ELSIF arrInputAddress[0] = BYTE#16#3E <br/>	AND arrInputAddress[1] = BYTE#16#00<br/>    AND xCommandChanged THEN<br/>
									<br/>		IF xConsoleLog THEN<br/>			Console.strSource			:= strConsoleId;<br/>			Console.strMessage			:= 'ReadCounters command';<br/>			Console();<br/>		END_IF;<br/>
									<br/>		arrOutputAddress[0] 		:= arrInputAddress[0];						(* Command mirror *)<br/>		arrOutputAddress[1] 		:= bStatusBits;								(* Status bits *)<br/>
									<br/>		wBytesReceived				:= INT_TO_WORD(iBytesReceived);<br/>		arrOutputAddress[2]			:= wWordsReceived.B0;<br/>		arrOutputAddress[3]			:= wWordsReceived.B1;<br/>
									<br/>		wBytesTransmitted			:= INT_TO_WORD(iBytesTransmitted);<br/>		arrOutputAddress[7]			:= wWordsTransmitted.B0;<br/>		arrOutputAddress[8]			:= wWordsTransmitted.B1;<br/>
									<br/>(* "Write configuration" command *)<br/>ELSIF arrInputAddress[0] = BYTE#16#40<br/>    AND xCommandChanged THEN<br/>
									<br/>	IF xConsoleLog THEN<br/>		Console.strSource			:= strConsoleId;<br/>		Console.strMessage			:= 'Write configuration command';<br/>		Console();<br/>	END_IF;<br/>
									<br/>	arrOutputAddress[0] 		:= arrInputAddress[0];						(* Command mirror *)<br/>	arrOutputAddress[1] 		:= bStatusBits;								(* Status bits *)<br/>
									<br/>ELSIF xCommandChanged THEN<br/>
									<br/>	IF xConsoleLog THEN<br/>		Console.strSource			:= strConsoleId;<br/>		Console.strMessage			:= CONCAT(BYTE_TO_STRING(arrInputAddress[0], '%x'),' command');<br/>		Console();<br/>	END_IF;<br/>
									<br/>	arrOutputAddress[0] 		:= 	arrInputAddress[0];						(* Command mirror *)<br/>
									<br/>END_IF;<br/>
									<br/>(* ============================================================================================================== *)<br/>
									<br/>
									<br/>(* ==================================== Clear xSending flag if command is changing ============================== *)<br/>(*<br/>IF arrInputAddress[0] &lt;&gt; BYTE#16#10  <br/>	AND arrInputAddress[0] &lt;&gt; BYTE#16#50 <br/>	THEN<br/>
									<br/>		xSending	:= FALSE;<br/>
									<br/>END_IF;<br/>*)<br/>(* ============================================================================================================== *)<br/>
									<br/>
									<br/>(* ================================= Sending data from internal buffer to serial interface ====================== *)<br/>IF xSending THEN<br/>        xSending                        := FALSE;<br/>
									<br/>		IF xConsoleLog THEN<br/>			Console.strSource			:= strConsoleId;<br/>			Console.strMessage			:= CONCAT('Sending to interface, length ', INT_TO_STRING(udtBufferSend.iLength, '%d'));<br/>			Console();<br/>		END_IF;<br/>
									<br/>        (* Clear RS485 Line *)<br/>        BufferHandler.xClear            := TRUE;<br/>        BufferHandler.xPull             := FALSE;<br/>        BufferHandler.xPush             := FALSE;<br/>        BufferHandler.udtBuffer         := udtRS485Line;<br/>        BufferHandler();<br/>        udtRS485Line                    := BufferHandler.udtBuffer;<br/>
									<br/>        WHILE NOT udtBufferSend.xEmpty DO<br/>            (* Pull from internal buffer *)<br/>            BufferHandler.xPull             := TRUE;<br/>            BufferHandler.xPush             := FALSE;<br/>            BufferHandler.udtBuffer         := udtBufferSend;<br/>            BufferHandler();<br/>            udtBufferSend                   := BufferHandler.udtBuffer;<br/>
									<br/>            bPulledByte                     := BufferHandler.bPulledByte;<br/>
									<br/>            (* Push to RS485 Line *)<br/>            IF NOT BufferHandler.xError THEN<br/>                BufferHandler.xPull          := FALSE;<br/>                BufferHandler.xPush          := TRUE;<br/>                BufferHandler.bPushByte      := bPulledByte;<br/>                BufferHandler.udtBuffer      := udtRS485Line;<br/>                BufferHandler();<br/>                udtRS485Line                := BufferHandler.udtBuffer;<br/>            END_IF;<br/>
									<br/>            (* Counter update *)<br/>            iBytesTransmitted               := iBytesTransmitted + 1;<br/>        END_WHILE;<br/>
									<br/>        udtRS485Line.udiRev                 := udtRS485Line.udiRev + UDINT#1;<br/>        udiRevRemembered                    := udtRS485Line.udiRev;<br/>
									<br/>(* ======================================== Copy data from interface to internal buffer ======================= *)<br/>ELSIF NOT xSending <br/>	AND NOT udtRS485Line.xEmpty <br/>    AND udiRevRemembered &lt;&gt; udtRS485Line.udiRev THEN<br/>
									<br/>		IF xConsoleLog THEN<br/>			Console.strSource				:= strConsoleId;<br/>			Console.strMessage				:= CONCAT('Receiving from interface, length ', INT_TO_STRING(udtRS485Line.iLength, '%d'));<br/>			Console();<br/>		END_IF;<br/>
									<br/>        udtRS485LineCopy                    := udtRS485Line;<br/>
									<br/>        WHILE NOT udtRS485LineCopy.xEmpty DO<br/>            (* Pull from RS485 Line *)<br/>            BufferHandler.xPull             := TRUE;<br/>            BufferHandler.xPush             := FALSE;<br/>            BufferHandler.udtBuffer         := udtRS485LineCopy;<br/>            BufferHandler();<br/>            udtRS485LineCopy                := BufferHandler.udtBuffer;<br/>
									<br/>            bPulledByte                     := BufferHandler.bPulledByte;<br/>
									<br/>            (* Push to internal buffer *)<br/>            IF NOT BufferHandler.xError THEN<br/>                BufferHandler.xPull          := FALSE;<br/>                BufferHandler.xPush          := TRUE;<br/>                BufferHandler.bPushByte      := bPulledByte;<br/>                BufferHandler.udtBuffer      := udtBufferReceive;<br/>                BufferHandler();<br/>                udtBufferReceive             := BufferHandler.udtBuffer;<br/>            END_IF;<br/>
									<br/>            (* Counter update *)<br/>            iBytesReceived                   := iBytesReceived + 1;<br/>        END_WHILE;<br/>
									<br/>
									<br/>		udiRevRemembered 	                 := udtRS485Line.udiRev;<br/>END_IF;<br/>(* ============================================================================================================== *)<br/>
									<br/>(* Update buffers Info *)<br/>BufferHandler.xPull          := FALSE;<br/>BufferHandler.xPush          := FALSE;<br/>BufferHandler.xClear         := FALSE;<br/>BufferHandler.bPushByte      := bPulledByte;<br/>BufferHandler.udtBuffer      := udtBufferReceive;<br/>BufferHandler();<br/>udtBufferReceive             := BufferHandler.udtBuffer;<br/>
									<br/>BufferHandler.xPull          := FALSE;<br/>BufferHandler.xPush          := FALSE;<br/>BufferHandler.xClear         := FALSE;<br/>BufferHandler.bPushByte      := bPulledByte;<br/>BufferHandler.udtBuffer      := udtBufferSend;<br/>BufferHandler();<br/>udtBufferSend                := BufferHandler.udtBuffer;<br/>
									<br/>BufferHandler.xPull          := FALSE;<br/>BufferHandler.xPush          := FALSE;<br/>BufferHandler.xClear         := FALSE;<br/>BufferHandler.bPushByte      := bPulledByte;<br/>BufferHandler.udtBuffer      := udtRS485Line;<br/>BufferHandler();<br/>udtRS485Line                 := BufferHandler.udtBuffer;<br/>
									<br/>udiRevRemembered             := udtRS485Line.udiRev;<br/>
								</p>
							</html>
						</worksheet>
					</ST>
				</body>
				<documentation>
					<html xmlns="http://www.w3.org/1999/xhtml">
						<div xml:space="preserve" id="MWTDESCRIPTION" wsName="AXL_F_RSUNIT" xmlns="http://www.w3.org/1999/xhtml"/>
					</html>
				</documentation>
			</pou>
		</pous>
	</types>
	<instances>
		<configurations/>
	</instances>
</project>